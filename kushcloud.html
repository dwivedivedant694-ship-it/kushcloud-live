<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>KushCloud â€” Live Crypto Tracker</title>

<!-- Chart.js + financial plugin -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@3.0.0/dist/chartjs-chart-financial.min.js"></script>

<style>
:root{
  --bg:#07101a; --card:#0f1724; --muted:#94a3b8; --accent:#00b7ff; --accent-2:#38bdf8;
  --up:#22c55e; --down:#ef4444; --glass: rgba(255,255,255,0.03);
  --radius:12px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;background:linear-gradient(180deg,#07101a,#081425 110%);color:#e6eef8;
  font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Poppins,Arial; -webkit-font-smoothing:antialiased;
  padding:16px;
}

/* header / brand */
.header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
.brand{display:flex;align-items:center;gap:12px}
.logoWrap{display:flex;align-items:center;gap:10px}
.logoBox{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),var(--accent-2));
 display:flex;align-items:center;justify-content:center;box-shadow:0 6px 18px rgba(0,183,255,0.12)}
.logoBox svg{width:28px;height:28px}
.title{font-size:18px;font-weight:700}
.subtitle{font-size:12px;color:var(--muted)}

/* search */
.searchRow{display:flex;gap:10px;align-items:center;margin-bottom:12px}
.searchInput{
  flex:1;padding:12px 14px;border-radius:12px;border:none;background:var(--card);color:#fff;font-size:16px;
  outline: 2px solid transparent; transition:outline .12s, transform .08s;
}
.searchInput:focus{outline:2px solid rgba(56,189,248,0.14);transform:translateY(-1px)}
.searchBtn{padding:10px 12px;border-radius:10px;border:none;background:var(--accent);color:#021024;font-weight:600;cursor:pointer}

/* layout */
.grid{display:grid;grid-template-columns:1fr;gap:12px}
@media(min-width:900px){ .grid{grid-template-columns:1fr 420px} }

.card{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:12px;border-radius:var(--radius);border:1px solid rgba(255,255,255,0.02)}
.cardRow{display:flex;justify-content:space-between;align-items:center}

/* coin card */
.coin{font-weight:700;font-size:16px}
.infoSmall{font-size:13px;color:var(--muted)}
.price{font-weight:700;font-size:16px}
.changeUp{color:var(--up);font-weight:700}
.changeDown{color:var(--down);font-weight:700}

/* sections */
.sectionTitle{color:var(--accent);font-weight:700;margin:6px 0}

/* modal */
#modal{position:fixed;inset:0;background:rgba(0,0,0,0.75);display:none;align-items:center;justify-content:center;z-index:9999;padding:10px}
.modalBox{width:100%;max-width:980px;background:linear-gradient(180deg,#071825,#06101a);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);max-height:94vh;overflow:auto}
.controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin-bottom:10px}
.btn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#e6eef8;padding:8px 10px;border-radius:8px;cursor:pointer;font-size:13px}
.btn.active{background:var(--accent);color:#021024;border:none}
.meta{color:var(--muted);font-size:13px;margin-bottom:8px}

/* footer */
.footer{text-align:center;color:var(--muted);margin-top:18px;font-size:13px}

/* small helpers */
.row{display:flex;gap:8px;align-items:center}
.spacer{height:12px}
.spinner{width:16px;height:16px;border-radius:50%;border:2px solid rgba(255,255,255,0.06);border-top-color:var(--accent);animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
</style>
</head>
<body>

<!-- header -->
<div class="header">
  <div class="brand">
    <div class="logoWrap">
      <div class="logoBox" aria-hidden>
        <!-- simple px logo -->
        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect x="2" y="2" width="20" height="20" rx="4" fill="white" opacity="0.06"/>
          <path d="M5 15 L9 9 L13 13 L19 7" stroke="#021024" stroke-width="1.8" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>
      <div>
        <div class="title">KushCloud</div>
        <div class="subtitle">Live Crypto â€¢ Binance data</div>
      </div>
    </div>
    </div>

  <div class="subtitle" id="liveClock">Live</div>
</div>

<!-- search -->
<div class="searchRow">
  <input id="searchBox" class="searchInput" placeholder="Search pair (BTCUSDT, ETHUSDT). Type & press Enter" />
  <button id="searchBtn" class="searchBtn">Open</button>
</div>

<!-- main grid -->
<div class="grid">
  <div>
    <div id="singleResult" class="card" style="min-height:72px">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="coin" id="srSymbol">BTCUSDT</div>
          <div class="infoSmall" id="srSub">Price & 24h info</div>
        </div>
        <div style="text-align:right">
          <div class="price" id="srPrice">â‚¹-</div>
          <div class="infoSmall" id="srChange">-</div>
        </div>
      </div>
      <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
        <button id="openChartBtn" class="btn">Open Chart</button>
        <div style="margin-left:auto" class="infoSmall" id="srVol">Vol -</div>
      </div>
    </div>

    <div class="spacer"></div>

    <div class="sectionTitle">ðŸš€ Top Gainers</div>
    <div id="topGainers" class="card"></div>

    <div class="spacer"></div>

    <div class="sectionTitle">ðŸ“‰ Top Losers</div>
    <div id="topLosers" class="card"></div>
  </div>

  <div>
    <div class="card" style="display:flex;flex-direction:column;gap:10px">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="coin" id="sideSymbol">BTCUSDT</div>
          <div class="infoSmall" id="sideSub">Pair â€¢ Quick info</div>
        </div>
        <div style="text-align:right">
          <div class="price" id="sidePrice">â‚¹-</div>
          <div class="infoSmall" id="sideChange">-</div>
        </div>
      </div>

      <div style="display:flex;gap:8px;align-items:center">
        <button id="sideOpen" class="btn">Open Chart</button>
        <div style="margin-left:auto" class="infoSmall" id="sideVol">Vol -</div>
      </div>
      <div class="infoSmall">Tip: Click card or search a pair then press Enter to open chart.</div>
    </div>
  </div>
</div>

<div class="footer">Made by Vedant Dwivedi</div>

<!-- modal -->
<div id="modal" role="dialog" aria-hidden="true">
  <div class="modalBox">
    <div class="controls">
      <div class="row" id="intervalButtons"></div>
      <div class="row">
        <button id="downloadCsv" class="btn">CSV</button>
        <button id="closeBtn" class="btn">Close</button>
      </div>
    </div>

    <div class="meta" id="metaInfo">Loading...</div>
    <canvas id="chartCanvas" height="420"></canvas>
  </div>
</div>

<script>
/* --------------- Core app logic --------------- */
/* Uses Binance public REST
   - True candlesticks via /klines with pagination
   - 1s mode uses ticker/price polling
   - Designed mobile-first, host via HTTPS (GitHub Pages recommended)
*/

const el = id => document.getElementById(id);
const searchBox = el('searchBox'), searchBtn = el('searchBtn');
const singleResult = el('singleResult'), srSymbol = el('srSymbol'), srSub = el('srSub'), srPrice = el('srPrice'), srChange = el('srChange'), srVol = el('srVol');
const sideSymbol = el('sideSymbol'), sidePrice = el('sidePrice'), sideChange = el('sideChange'), sideVol = el('sideVol');
const openChartBtn = el('openChartBtn'), sideOpen = el('sideOpen');
const topGainers = el('topGainers'), topLosers = el('topLosers');
const modal = el('modal'), closeBtn = el('closeBtn'), metaInfo = el('metaInfo'), chartCanvas = el('chartCanvas'), downloadCsv = el('downloadCsv');
const liveClock = el('liveClock');
let chart=null, liveTickTimer=null;
let currentSymbol = 'BTCUSDT', currentInterval = '1m';

// intervals to show in UI
const INTERVALS = ['1s','1m','5m','15m','1h','4h','12h','1d','1w','1M','3M','6M','1y','2y','3y','4y','5y'];

// mapping ms for some intervals (approx)
const MS = {
  '1s':1000,'1m':60*1000,'5m':5*60*1000,'15m':15*60*1000,'30m':30*60*1000,'1h':60*60*1000,'4h':4*60*60*1000,'12h':12*60*60*1000,'1d':24*60*60*1000,'1w':7*24*60*60*1000,'1M':30*24*60*60*1000
};

// helper: fetch JSON with error handling
async function fetchJson(url){
  const res = await fetch(url);
  if(!res.ok) throw new Error('HTTP '+res.status);
  return await res.json();
}

// update clock
function tickClock(){ liveClock.innerText = 'Live â€¢ ' + new Date().toLocaleTimeString(); }
tickClock(); setInterval(tickClock,1000);

// simple formatter
function fmtINR(x){ if(!isFinite(x)) return '-'; if(x>1000) return 'â‚¹'+Math.round(x).toLocaleString(); return 'â‚¹'+Number(x).toFixed(2); }
function fmtShort(x){ if(!isFinite(x)) return '-'; if(Math.abs(x)>=1e6) return (x/1e6).toFixed(2)+'M'; if(Math.abs(x)>=1e3) return (x/1e3).toFixed(2)+'K'; return Number(x).toFixed(2); }

// fetch ticker 24hr
async function loadTicker24(symbol){
  try{
    const info = await fetchJson('https://api.binance.com/api/v3/ticker/24hr?symbol='+symbol);
    return info;
  }catch(e){
    return null;
  }
}

// update the single result card quickly
async function updateSingle(symbol){
  try{
    const d = await fetchJson('https://api.binance.com/api/v3/ticker/price?symbol='+symbol);
    if(d && d.price){
      srSymbol.innerText = symbol;
      srPrice.innerText = fmtINR(parseFloat(d.price)*85.5);
      // get 24h
      const t24 = await loadTicker24(symbol);
      if(t24){
        srChange.innerText = (parseFloat(t24.priceChangePercent)>=0?'+':'') + parseFloat(t24.priceChangePercent).toFixed(2) + '%';
        srVol.innerText = 'Vol ' + fmtShort(parseFloat(t24.volume));
        // side
        sideSymbol.innerText = symbol;
        sidePrice.innerText = fmtINR(parseFloat(t24.lastPrice)*85.5);
        sideChange.innerText = (parseFloat(t24.priceChangePercent)>=0?'+':'') + parseFloat(t24.priceChangePercent).toFixed(2) + '%';
        sideVol.innerText = 'Vol ' + fmtShort(parseFloat(t24.volume));
      }
    } else {
      srSymbol.innerText = symbol;
      srPrice.innerText = '-';
    }
  }catch(e){
    srSymbol.innerText = symbol;
    srPrice.innerText = '-';
  }
}

// top lists
function cardHtml(c){
  const change = parseFloat(c.priceChangePercent||0);
  return `<div style="padding:10px;border-radius:8px;margin-bottom:8px;background:transparent;display:flex;justify-content:space-between;align-items:center" class="cardItem" data-symbol="${c.symbol}">
    <div>
      <div style="font-weight:700">${c.symbol}</div>
      <div class="infoSmall">${c.symbol.replace('USDT','')}</div>
    </div>
    <div style="text-align:right">
      <div style="font-weight:700">${change>=0?'+':''}${change.toFixed(2)}%</div>
    </div>
  </div>`;
}

async function fetchTopLists(){
  try{
    const data = await fetchJson('https://api.binance.com/api/v3/ticker/24hr');
    data.sort((a,b)=>parseFloat(b.priceChangePercent)-parseFloat(a.priceChangePercent));
    const gainers = data.slice(0,10), losers = data.slice(-10).reverse();
    topGainers.innerHTML = gainers.map(cardHtml).join('');
    topLosers.innerHTML = losers.map(cardHtml).join('');
    // attach events
    document.querySelectorAll('.cardItem').forEach(el=>{
      el.onclick = ()=> openChart(el.dataset.symbol);
    });
  }catch(e){
    topGainers.innerHTML = '<div class="infoSmall">Failed to load</div>';
    topLosers.innerHTML = '<div class="infoSmall">Failed to load</div>';
  }
}

// search handlers
searchBtn.onclick = ()=> {
  const q = searchBox.value.trim().toUpperCase();
  if(q) openChart(q);
};
searchBox.addEventListener('keyup', (e)=>{
  if(e.key === 'Enter'){ searchBtn.click(); return; }
  clearTimeout(window._searchT);
  window._searchT = setTimeout(()=> {
    const q = searchBox.value.trim().toUpperCase();
    if(q) updateSingle(q);
  }, 500);
});

// modal / chart code utilities
function destroyChart(){ try{ if(chart) chart.destroy(); }catch(e){} chart=null; if(liveTickTimer){ clearInterval(liveTickTimer); liveTickTimer=null; } }
function openModal(){ modal.style.display = 'flex'; modal.setAttribute('aria-hidden','false'); }
function closeModal(){ modal.style.display = 'none'; modal.setAttribute('aria-hidden','true'); destroyChart(); }

// create interval buttons
const intervalButtons = el('intervalButtons');
INTERVALS.forEach(iv=>{
  const b = document.createElement('button');
  b.className = 'btn';
  b.dataset.interval = iv;
  b.innerText = iv;
  b.onclick = async ()=>{
    document.querySelectorAll('#intervalButtons .btn').forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    currentInterval = iv;
    await loadAndRender(currentSymbol, currentInterval);
  };
  intervalButtons.appendChild(b);
});

// CSV download
downloadCsv.onclick = ()=>{
  if(!chart || !chart.data || !chart.data.datasets || !chart.data.datasets[0].data) return alert('No data');
  const rows=[['time','open','high','low','close','volume']];
  chart.data.datasets[0].data.forEach(d=>{
    rows.push([d.x.toISOString(), d.o, d.h, d.l, d.c, d.v || '']);
  });
  const csv = rows.map(r=>r.join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = currentSymbol + '_' + currentInterval + '.csv'; a.click();
};

// Binance helpers: fetch klines with pagination
async function fetchKlinesRange(symbol, interval, startTime=null, endTime=null){
  const MAX = 1000; let all=[];
  let next = startTime || null;
  // ensure symbol upper
  symbol = symbol.toUpperCase();
  while(true){
    const u = new URL('https://api.binance.com/api/v3/klines');
    u.searchParams.append('symbol', symbol);
    u.searchParams.append('interval', interval);
    u.searchParams.append('limit', MAX);
    if(next) u.searchParams.append('startTime', Math.floor(next));
    if(endTime) u.searchParams.append('endTime', Math.floor(endTime));
    const data = await fetchJson(u.toString());
    if(!Array.isArray(data) || data.length===0) break;
    all = all.concat(data);
    if(data.length < MAX) break;
    next = data[data.length-1][0] + 1;
    await new Promise(r=>setTimeout(r,120));
    if(all.length > 50000) break;
  }
  return all;
}

function rawToCandles(raw){
  return raw.map(k=>({ x: new Date(k[0]), o:+k[1], h:+k[2], l:+k[3], c:+k[4], v:+k[5] }));
}
function aggregateCandles(candles, targetMs){
  if(!candles || candles.length===0) return [];
  const res=[]; let bucketStart = Math.floor(candles[0].x.getTime()/targetMs)*targetMs; let bucket=null;
  for(const c of candles){
    const t = c.x.getTime(); const b = Math.floor(t/targetMs)*targetMs;
    if(b !== bucketStart){
      if(bucket) res.push(bucket);
      bucketStart = b;
      bucket = { x: new Date(bucketStart), o:c.o, h:c.h, l:c.l, c:c.c, v:c.v };
      continue;
    }
    bucket.h = Math.max(bucket.h, c.h);
    bucket.l = Math.min(bucket.l, c.l);
    bucket.c = c.c;
    bucket.v = bucket.v + c.v;
  }
  if(bucket) res.push(bucket);
  return res;
}

// pick base interval & factor for aggregation
const SUPPORTED = ['1M','1w','1d','12h','8h','6h','4h','2h','1h','30m','15m','5m','3m','1m'];
const MS = {'1m':60000,'3m':180000,'5m':300000,'15m':900000,'30m':1800000,'1h':3600000,'2h':7200000,'4h':14400000,'6h':21600000,'8h':28800000,'12h':43200000,'1d':86400000,'1w':604800000,'1M':2592000000};

function chooseBaseInterval(target){
  if(target === '1s') return {base:'1m', factor:'tick'};
  if(MS[target]) return {base:target, factor:1};
  // compute approximate target ms
  let tgtMs;
  if(target.endsWith('M')) tgtMs = parseInt(target)*30*86400000;
  else if(target.endsWith('y')) tgtMs = parseInt(target)*365*86400000;
  else tgtMs = MS[target] || 86400000;
  for(const s of SUPPORTED){
    if(MS[s] <= tgtMs){
      const factor = Math.round(tgtMs / MS[s]) || 1;
      return {base:s, factor};
    }
  }
  return {base:'1d', factor: Math.round(tgtMs / 86400000) || 1};
}

// high-level fetcher for any requested interval (real data)
async function getCandlesFor(symbol, requestedInterval){
  if(requestedInterval === '1s') return {type:'ticks'};
  const {base, factor} = chooseBaseInterval(requestedInterval);
  // determine a reasonable startTime for long ranges (3M/6M/1y etc.)
  const end = Date.now();
  let start = null;
  if(requestedInterval.endsWith('y')) start = end - parseInt(requestedInterval)*365*86400000;
  else if(requestedInterval.endsWith('M') && parseInt(requestedInterval) >= 3) start = end - parseInt(requestedInterval)*30*86400000;
  // fetch raw
  const raw = await fetchKlinesRange(symbol, base, start, end);
  const candles = rawToCandles(raw);
  if(factor && factor > 1){
    const targetMs = (MS[base] || 86400000) * factor;
    const agg = aggregateCandles(candles, targetMs);
    return {type:'candles', data:agg};
  }
  return {type:'candles', data:candles};
}

// render functions
function renderCandles(candles, symbol){
  destroyChart();
  const ctx = chartCanvas.getContext('2d');
  chart = new Chart(ctx, {
    type: 'candlestick',
    data: { datasets: [{ label: symbol, data: candles }] },
    options: {
      plugins:{legend:{display:false}},
      scales:{ x:{ticks:{color:'#cbd5e1'}}, y:{ticks:{color:'#cbd5e1'}} }
    }
  });
}

function renderTicks(points, symbol){
  destroyChart();
  const ctx = chartCanvas.getContext('2d');
  chart = new Chart(ctx, {
    type: 'line',
    data: { labels: points.map(p=>p.t.toLocaleTimeString()), datasets:[{label:symbol,data:points.map(p=>p.p),borderColor:'#00b7ff',tension:0.15}] },
    options:{plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#cbd5e1'}},y:{ticks:{color:'#cbd5e1'}}}}
  });
}

// load and display chart for symbol+interval
async function loadAndRender(symbol, interval){
  try{
    destroyChart();
    metaInfo.innerText = `Loading ${symbol} â€¢ ${interval} ...`;
    // show quick 24h info
    const info = await loadTicker24(symbol);
    if(info){
      metaInfo.innerText = `${symbol} â€¢ High: ${info.highPrice} â€¢ Low: ${info.lowPrice} â€¢ Vol: ${fmtShort(parseFloat(info.volume))} â€¢ Change: ${(parseFloat(info.priceChangePercent)>=0?'+':'')+parseFloat(info.priceChangePercent).toFixed(2)+'%'}`;
    }
    currentSymbol = symbol;
    currentInterval = interval;
    if(interval === '1s'){
      // tick mode
      const pts = [];
      let first = true;
      liveTickTimer = setInterval(async ()=>{
        try{
          const r = await fetchJson('https://api.binance.com/api/v3/ticker/price?symbol='+symbol);
          const p = parseFloat(r.price);
          pts.push({t:new Date(), p});
          if(pts.length>120) pts.shift();
          if(first){ renderTicks(pts, symbol); first=false; }
          else {
            if(chart && chart.data && chart.data.datasets){
              chart.data.labels = pts.map(x=>x.t.toLocaleTimeString());
              chart.data.datasets[0].data = pts.map(x=>x.p);
              chart.update('none');
            }
          }
        }catch(e){ console.log('tick err',e); }
      },1000);
      metaInfo.innerText = `Live tick â€¢ ${symbol}`;
      return;
    }
    // else candlestick intervals
    const res = await getCandlesFor(symbol, interval);
    if(res.type === 'candles' && res.data && res.data.length>0){
      renderCandles(res.data, symbol);
      metaInfo.innerText = `${symbol} â€¢ ${interval} â€¢ ${res.data.length} candles`;
    } else metaInfo.innerText = 'No candle data available';
  }catch(err){
    console.error(err); metaInfo.innerText = 'Chart load failed';
  }
}

// open/close modal
function openChart(symbol){
  currentSymbol = symbol.toUpperCase();
  modal.style.display = 'flex';
  document.querySelectorAll('#intervalButtons .